"""Renderer for Fern."""

from __future__ import annotations

import re
import typing as t

from autodoc2.render.base import RendererBase

if t.TYPE_CHECKING:
    from autodoc2.utils import ItemData


_RE_DELIMS = re.compile(r"(\s*[\[\]\(\),]\s*)")


class FernRenderer(RendererBase):
    """Render the documentation as Fern-compatible Markdown."""

    EXTENSION = ".md"

    def render_item(self, full_name: str) -> t.Iterable[str]:
        """Render a single item by dispatching to the appropriate method."""
        item = self.get_item(full_name)
        if item is None:
            raise ValueError(f"Item {full_name} does not exist")
        
        type_ = item["type"]
        if type_ == "package":
            yield from self.render_package(item)
        elif type_ == "module":
            yield from self.render_module(item)
        elif type_ == "function":
            yield from self.render_function(item)
        elif type_ == "class":
            yield from self.render_class(item)
        elif type_ == "exception":
            yield from self.render_exception(item)
        elif type_ == "property":
            yield from self.render_property(item)
        elif type_ == "method":
            yield from self.render_method(item)
        elif type_ == "attribute":
            yield from self.render_attribute(item)
        elif type_ == "data":
            yield from self.render_data(item)
        else:
            self.warn(f"Unknown item type {type_!r} for {full_name!r}")

    def render_function(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a function."""
        short_name = item["full_name"].split(".")[-1]
        full_name = item["full_name"]
        show_annotations = self.show_annotations(item)
        
        # Function header with full name (anchor auto-generated by markdown processor)
        yield f"## {full_name}"
        yield ""
        
        # Function signature in code block with proper formatting
        yield "```python"
        
        # Format function signature with newlines for readability
        args_formatted = self._format_args_multiline(item['args'], show_annotations)
        return_annotation = f" -> {self.format_annotation(item['return_annotation'])}" if show_annotations and item.get("return_annotation") else ""
        
        if args_formatted.count(',') >= 2:  # Multi-line if 3+ params
            yield f"def {full_name}("
            for line in args_formatted.split('\n'):
                if line.strip():
                    yield f"    {line.strip()}"
            yield f"){return_annotation}"
        else:
            # Single line for simple functions
            yield f"def {full_name}({args_formatted}){return_annotation}"
            
        yield "```"
        yield ""
        
        if self.show_docstring(item):
            # Parse and format docstring sections
            yield from self._format_docstring_sections(item['doc'])
        yield ""

    def render_module(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a module."""
        # For now, delegate to package rendering
        yield from self.render_package(item)

    def render_package(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a package."""
        full_name = item["full_name"]
        
        # Package header as proper title
        yield f"# {full_name}"
        yield ""
        
        if self.show_docstring(item):
            yield item['doc']
            yield ""

        # Get all children organized by type
        children_by_type = {
            "package": list(self.get_children(item, {"package"})),
            "module": list(self.get_children(item, {"module"})), 
            "class": list(self.get_children(item, {"class"})),
            "function": list(self.get_children(item, {"function"})),
            "data": list(self.get_children(item, {"data"})),
        }
        
        has_subpackages = bool(children_by_type["package"])
        has_submodules = bool(children_by_type["module"])
        has_content = any(children_by_type[t] for t in ["class", "function", "data"])
        
        # Show hierarchical structure if we have subpackages/modules
        if has_subpackages:
            yield "## Subpackages"
            yield ""
            for child in children_by_type["package"]:
                name = child["full_name"].split(".")[-1]
                doc_summary = child.get('doc', '').split('\n')[0][:80] if child.get('doc') else ""
                if len(child.get('doc', '')) > 80:
                    doc_summary += "..."
                yield f"- **[{name}](#{name.lower()})** - {doc_summary}" if doc_summary else f"- **[{name}](#{name.lower()})**"
            yield ""
            
        if has_submodules:
            yield "## Submodules" 
            yield ""
            for child in children_by_type["module"]:
                name = child["full_name"].split(".")[-1]
                doc_summary = child.get('doc', '').split('\n')[0][:80] if child.get('doc') else ""
                if len(child.get('doc', '')) > 80:
                    doc_summary += "..."
                yield f"- **[{name}](#{name.lower()})** - {doc_summary}" if doc_summary else f"- **[{name}](#{name.lower()})**"
            yield ""
        
        # Show Module Contents summary if we have actual content (not just submodules)
        if has_content:
            yield "## Module Contents"
            yield ""
            
            # Classes section - proper table format with full descriptions
            if children_by_type["class"]:
                yield "### Classes"
                yield ""
                yield "| Name | Description |"
                yield "|------|-------------|"
                for child in children_by_type["class"]:
                    full_name = child["full_name"]
                    short_name = full_name.split('.')[-1]
                    # Create anchor that matches auto-generated markdown anchors from headers
                    anchor = self._create_anchor(full_name)
                    name_link = f"[{short_name}](#{anchor})"
                    # Get full description (first paragraph, not truncated)
                    doc_lines = child.get('doc', '').strip().split('\n')
                    if doc_lines and doc_lines[0]:
                        # Get first paragraph (until empty line or end)
                        doc_summary = []
                        for line in doc_lines:
                            if not line.strip():
                                break
                            doc_summary.append(line.strip())
                        description = ' '.join(doc_summary) if doc_summary else ""
                    else:
                        description = ""
                    yield f"| {name_link} | {description} |"
                yield ""
            
            # Functions section - proper table format with full descriptions  
            if children_by_type["function"]:
                yield "### Functions"
                yield ""
                yield "| Name | Description |"
                yield "|------|-------------|"
                for child in children_by_type["function"]:
                    full_name = child["full_name"]
                    short_name = full_name.split('.')[-1]
                    # Create proper anchor that matches the header (use full name for anchor)
                    anchor = self._create_anchor(full_name)
                    name_link = f"[{short_name}](#{anchor})"
                    # Get full description (first paragraph, not truncated)
                    doc_lines = child.get('doc', '').strip().split('\n')
                    if doc_lines and doc_lines[0]:
                        # Get first paragraph (until empty line or end)
                        doc_summary = []
                        for line in doc_lines:
                            if not line.strip():
                                break
                            doc_summary.append(line.strip())
                        description = ' '.join(doc_summary) if doc_summary else ""
                    else:
                        description = ""
                    yield f"| {name_link} | {description} |"
                yield ""
                
            # Data section
            if children_by_type["data"]:
                yield "### Data"
                yield ""
                for child in children_by_type["data"]:
                    name = child["full_name"].split(".")[-1]
                    yield f"`{name}`"
                yield ""

        # API section with detailed documentation
        # Only render detailed content for items directly defined in this package/module  
        # (NOT subpackages/submodules - they get their own separate files)
        visible_children = [
            child["full_name"]
            for child in self.get_children(item)
            if child["type"] not in ("package", "module")
        ]
        
        if visible_children:
            yield "## API"
            yield ""
            
            for name in visible_children:
                yield from self.render_item(name)

    def render_class(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a class."""
        short_name = item["full_name"].split(".")[-1]
        
        # Build class signature with constructor args
        constructor = self.get_item(f"{item['full_name']}.__init__")
        sig = short_name
        if constructor and "args" in constructor:
            args = self.format_args(
                constructor["args"], self.show_annotations(item), ignore_self="self"
            )
            sig += f"({args})"

        # Class header with full name (smaller heading, anchor auto-generated)
        full_name = item["full_name"]
        yield f"### {full_name}"
        yield ""

        # Class signature in code block with full name
        yield "```python"
        yield f"class {item['full_name']}({args})" if constructor and "args" in constructor else f"class {item['full_name']}"
        yield "```"
        yield ""

        # Show inheritance if configured and available  
        if item.get("bases") and self.show_class_inheritance(item):
            base_list = ", ".join(
                f"`{self.format_base(base)}`" for base in item.get("bases", [])
            )
            yield f"**Bases**: {base_list}"
            yield ""

        # Class docstring
        if self.show_docstring(item):
            yield from self._format_docstring_sections(item['doc'])

            # Optionally merge __init__ docstring
            if self.config.class_docstring == "merge":
                init_item = self.get_item(f"{item['full_name']}.__init__")
                if init_item and init_item.get('doc'):
                    yield "### Initialization"
                    yield ""
                    yield from self._format_docstring_sections(init_item['doc'])
                    yield ""

        # Render class members (methods, properties, attributes)
        for child in self.get_children(
            item, {"class", "property", "attribute", "method"}
        ):
            # Skip __init__ if we merged its docstring above
            if (
                child["full_name"].endswith(".__init__")
                and self.config.class_docstring == "merge"
            ):
                continue
            
            # Render each member with increased heading level
            for line in self.render_item(child["full_name"]):
                # Convert ## to #### for nested members (skip ### to avoid conflicts)
                if line.startswith("## "):
                    yield "####" + line[2:]
                else:
                    yield line

    def render_exception(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for an exception."""
        yield from self.render_class(item)

    def render_property(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a property."""
        short_name = item["full_name"].split(".")[-1]
        
        # Property header with full name (anchor auto-generated)
        full_name = item["full_name"]
        header = f"### {full_name}"
        if item.get("return_annotation"):
            header += f": `{self.format_annotation(item['return_annotation'])}`"
        yield header
        yield ""
        
        # Show decorators if any
        properties = item.get("properties", [])
        if properties:
            decorator_list = []
            for prop in ("abstractmethod", "classmethod"):
                if prop in properties:
                    decorator_list.append(f"`@{prop}`")
            if decorator_list:
                yield f"**Decorators**: {', '.join(decorator_list)}"
                yield ""
        
        # Property docstring
        if self.show_docstring(item):
            yield from self._format_docstring_sections(item['doc'])
        yield ""

    def render_method(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a method."""
        yield from self.render_function(item)  # Same as function for now

    def render_attribute(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for an attribute."""
        yield from self.render_data(item)

    def render_data(self, item: ItemData) -> t.Iterable[str]:
        """Create the content for a data item."""
        full_name = item["full_name"]
        yield f"### {full_name}"
        
        if item.get("annotation"):
            yield f"**Type**: `{self.format_annotation(item['annotation'])}`"
        
        value = item.get("value")
        if value is not None:
            yield f"**Value**: `{value}`"
        
        if self.show_docstring(item):
            yield ""
            yield item['doc']
        yield ""

    def generate_summary(
        self, objects: list[ItemData], alias: dict[str, str] | None = None
    ) -> t.Iterable[str]:
        """Generate a summary of the objects."""
        alias = alias or {}
        
        yield "| Name | Description |"
        yield "|------|-------------|"
        
        for item in objects:
            full_name = item["full_name"]
            display_name = alias.get(full_name, full_name.split(".")[-1])
            
            # Get first line of docstring for description
            doc = item.get('doc', '').strip()
            description = doc.split('\n')[0] if doc else ""
            if len(description) > 50:
                description = description[:47] + "..."
            
            yield f"| `{display_name}` | {description} |"

    def _format_docstring_sections(self, docstring: str) -> t.Iterable[str]:
        """Parse docstring into structured sections like Parameters, Returns, etc."""
        if not docstring.strip():
            return
            
        lines = docstring.strip().split('\n')
        
        # Parse into sections
        sections = {"description": [], "parameters": [], "returns": [], "raises": []}
        current_section = "description"
        
        i = 0
        while i < len(lines):
            line = lines[i]
            line_stripped = line.strip()
            line_lower = line_stripped.lower()
            
            # Check for section headers (Google/Numpy style)
            if line_lower in ('args:', 'arguments:', 'parameters:', 'params:'):
                current_section = "parameters"
                i += 1
                continue
            elif line_lower in ('returns:', 'return:', 'yields:', 'yield:'):
                current_section = "returns"
                i += 1
                continue
            elif line_lower in ('raises:', 'raise:', 'except:', 'exceptions:'):
                current_section = "raises"
                i += 1
                continue
            
            # Check for RST-style parameters
            elif line_stripped.startswith(':param '):
                if ':' in line_stripped[7:]:
                    param_part = line_stripped[7:]
                    if ':' in param_part:
                        name, desc = param_part.split(':', 1)
                        sections["parameters"].append(f"**{name.strip()}**: {desc.strip()}")
                i += 1
                continue
                
            elif line_stripped.startswith((':return:', ':returns:', ':rtype:')):
                if ':' in line_stripped:
                    parts = line_stripped.split(':', 2)
                    if len(parts) >= 3:
                        sections["returns"].append(parts[2].strip())
                i += 1
                continue
            
            # Add line to current section
            sections[current_section].append(line)
            i += 1
        
        # Output formatted sections
        # Description first
        if sections["description"]:
            desc_lines = []
            for line in sections["description"]:
                desc_lines.append(line)
            desc_text = '\n'.join(desc_lines).strip()
            if desc_text:
                yield desc_text
                yield ""
        
        # Parameters section
        if sections["parameters"]:
            yield "**Parameters:**"
            yield ""
            for line in sections["parameters"]:
                if line.strip():
                    # Google style: "    param_name: description"
                    if line.strip() and ':' in line:
                        # Remove leading whitespace and parse
                        param_line = line.strip()
                        if ':' in param_line:
                            name, desc = param_line.split(':', 1)
                            yield f"- **{name.strip()}**: {desc.strip()}"
                        else:
                            yield f"- {param_line}"
                    elif line.strip():
                        # Continuation line
                        yield f"  {line.strip()}"
            yield ""
            
        # Returns section
        if sections["returns"]:
            yield "**Returns:**"
            yield ""
            for line in sections["returns"]:
                if line.strip():
                    yield line.strip()
            yield ""
            
        # Raises section
        if sections["raises"]:
            yield "**Raises:**"
            yield ""
            for line in sections["raises"]:
                if line.strip():
                    yield line.strip()
            yield ""

    def _format_args_multiline(self, args_info, include_annotations: bool = True, ignore_self: str | None = None) -> str:
        """Format function arguments with newlines for better readability."""
        if not args_info:
            return ""
            
        formatted_args = []
        
        for i, (prefix, name, annotation, default) in enumerate(args_info):
            if i == 0 and ignore_self is not None and name == ignore_self:
                continue
                
            annotation = self.format_annotation(annotation) if annotation else ""
            
            # Build the argument string
            arg_str = (prefix or "") + (name or "")
            if annotation and include_annotations:
                arg_str += f": {annotation}"
            if default:
                arg_str += f" = {default}"
                
            formatted_args.append(arg_str)
        
        # If we have many arguments or long arguments, use multiline format
        args_str = ", ".join(formatted_args)
        if len(args_str) > 80 or len(formatted_args) >= 3:
            # Multi-line format: each arg on its own line
            return ",\n".join(formatted_args)
        else:
            # Single line format
            return args_str

    def _create_anchor(self, text: str) -> str:
        """Create a markdown anchor from header text, following standard markdown rules."""
        import re
        # Convert to lowercase
        anchor = text.lower()
        # Replace spaces with hyphens
        anchor = re.sub(r'\s+', '-', anchor)
        # Remove non-alphanumeric characters except hyphens and underscores
        anchor = re.sub(r'[^a-z0-9\-_]', '', anchor)
        # Remove duplicate hyphens
        anchor = re.sub(r'-+', '-', anchor)
        # Remove leading/trailing hyphens
        anchor = anchor.strip('-')
        return anchor